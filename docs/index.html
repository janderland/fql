<!DOCTYPE html>
<html>
<head>
  <title>FQL</title>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@300..700&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap" rel="stylesheet">
  <link href="css/code.css" rel="stylesheet" >
  <link href="css/style.css" rel="stylesheet"/>
  <script src="js/highlight.js"></script>
  <script src="js/fql.js"></script>
  <script src="js/go.js"></script>
  <script src="js/ebnf.js"></script>
  <script src="js/python.js"></script>
</head>
<body>
  <h1>FQL</h1>
    <pre class="language-fql query"><code>/user/index/surname(&quot;Johnson&quot;,&lt;userID:int&gt;)
/user(:userID,...)</code></pre>
    <pre class="language-fql result"><code>/user(9323,&quot;Timothy&quot;,&quot;Johnson&quot;,37)=nil
/user(24335,&quot;Andrew&quot;,&quot;Johnson&quot;,42)=nil
/user(33423,&quot;Ryan&quot;,&quot;Johnson&quot;,0x0ffa83,42.2)=nil</code></pre>
    <p>FQL is an <a href="https://github.com/janderland/fql">open
    source</a> query language for <a
    href="https://www.foundationdb.org/">FoundationDB</a>. It‚Äôs query
    semantics mirror FoundationDB‚Äôs <a
    href="https://apple.github.io/foundationdb/data-modeling.html">core
    data model</a>. Fundamental patterns like range-reads and
    indirection are first class citizens.</p>
    <ul>
    <li><a href="#introduction"
    id="toc-introduction">Introduction</a></li>
    <li><a href="#syntax" id="toc-syntax">Syntax</a>
    <ul>
    <li><a href="#overview" id="toc-overview">Overview</a></li>
    <li><a href="#data-elements" id="toc-data-elements">Data
    Elements</a></li>
    <li><a href="#tuples" id="toc-tuples">Tuples</a></li>
    <li><a href="#directories" id="toc-directories">Directories</a></li>
    <li><a href="#key-values" id="toc-key-values">Key-Values</a></li>
    <li><a href="#holes-schemas" id="toc-holes-schemas">Holes &amp;
    Schemas</a></li>
    <li><a href="#space-comments" id="toc-space-comments">Space &amp;
    Comments</a></li>
    <li><a href="#options" id="toc-options">Options</a>
    <ul>
    <li><a href="#element-options" id="toc-element-options">Element
    Options</a></li>
    <li><a href="#query-options" id="toc-query-options">Query
    Options</a></li>
    </ul></li>
    </ul></li>
    <li><a href="#semantics" id="toc-semantics">Semantics</a>
    <ul>
    <li><a href="#data-encoding" id="toc-data-encoding">Data
    Encoding</a></li>
    <li><a href="#query-types" id="toc-query-types">Query Types</a>
    <ul>
    <li><a href="#mutations" id="toc-mutations">Mutations</a></li>
    <li><a href="#reads" id="toc-reads">Reads</a></li>
    <li><a href="#directories-1"
    id="toc-directories-1">Directories</a></li>
    <li><a href="#filtering" id="toc-filtering">Filtering</a></li>
    </ul></li>
    <li><a href="#advanced-queries" id="toc-advanced-queries">Advanced
    Queries</a>
    <ul>
    <li><a href="#indirection" id="toc-indirection">Indirection</a></li>
    </ul></li>
    </ul></li>
    <li><a href="#grammar" id="toc-grammar">Grammar</a></li>
    </ul>
  <h1 id="introduction">Introduction</h1>
  <p>This document serves as both a language specification and a usage
  guide for FQL. The <a href="#syntax">Syntax</a> section describes the
  structure of queries while the <a href="#semantics">Semantics</a>
  section describes their behavior. The complete <a href="#grammar">EBNF
  grammar</a> appears at the end.</p>
  <p>Throughout the document, relevant grammar rules are shown alongside
  the features they define. Python code snippets demonstrate equivalent
  FoundationDB API calls.</p>
  <h1 id="syntax">Syntax</h1>
  <h2 id="overview">Overview</h2>
  <p>FQL is specified as a context-free <a href="#grammar">grammar</a>.
  The queries look like key-values encoded using the <a
  href="https://apple.github.io/foundationdb/developer-guide.html#directories">directory</a>
  and <a
  href="https://apple.github.io/foundationdb/data-modeling.html#data-modeling-tuples">tuple</a>
  layers. To the left of the <code>=</code> is the key which includes a
  directory path and tuple. To the right is the value.</p>
  <pre class="language-ebnf grammar"><code>query = options keyval | options key | options directory
keyval = key &#39;=&#39; value
key = directory tuple
value = &#39;clear&#39; | data</code></pre>
  <p>A query may be a full key-value, just a key, or just a directory.
  Query <a href="#options">options</a> may precede the query on the
  previous line.</p>
  <pre class="language-fql query"><code>/my/directory(&quot;my&quot;,&quot;tuple&quot;)=4000</code></pre>
  <p>FQL queries may define a single key-value to be written, as shown
  above, or may define a set of key-values to be read, as shown
  below.</p>
  <pre class="language-fql query"><code>/my/directory(&quot;my&quot;,&quot;tuple&quot;)=&lt;int&gt;</code></pre>
  <pre class="language-fql result"><code>/my/directory(&quot;my&quot;,&quot;tuple&quot;)=4000</code></pre>
  <p>The query above has the variable <code>&lt;int&gt;</code> as its
  value. Variables act as placeholders for any of the supported <a
  href="#data-elements">data elements</a>.</p>
  <p>FQL queries may also perform <a
  href="https://apple.github.io/foundationdb/developer-guide.html#range-reads">range
  reads</a> and filtering by including a variable in the key‚Äôs tuple.
  The query below will return all key-values which conform to the schema
  defined by the query.</p>
  <pre class="language-fql query"><code>/my/directory(&lt;&gt;,&quot;tuple&quot;)=nil</code></pre>
  <pre class="language-fql result"><code>/my/directory(&quot;your&quot;,&quot;tuple&quot;)=nil
/my/directory(42,&quot;tuple&quot;)=nil</code></pre>
  <p>The variable <code>&lt;&gt;</code> in the query above lacks a type.
  This means the schema allows any <a href="#data-elements">data
  element</a> at the variable‚Äôs position.</p>
  <p>All key-values with a certain key prefix may be range read by
  ending the key‚Äôs tuple with <code>...</code>.</p>
  <pre class="language-fql query"><code>/my/directory(&quot;my&quot;,&quot;tuple&quot;,...)=&lt;&gt;</code></pre>
  <pre class="language-fql result"><code>/my/directory(&quot;my&quot;,&quot;tuple&quot;)=0x0fa0
/my/directory(&quot;my&quot;,&quot;tuple&quot;,47.3)=0x8f3a
/my/directory(&quot;my&quot;,&quot;tuple&quot;,false,0xff9a853c12)=nil</code></pre>
  <p>A query‚Äôs value may be omitted to imply the variable
  <code>&lt;&gt;</code>, meaning the following query is semantically
  identical to the one above.</p>
  <pre class="language-fql query"><code>/my/directory(&quot;my&quot;,&quot;tuple&quot;,...)</code></pre>
  <pre class="language-fql result"><code>/my/directory(&quot;my&quot;,&quot;tuple&quot;)=0x0fa0
/my/directory(&quot;my&quot;,&quot;tuple&quot;,47.3)=0x8f3a
/my/directory(&quot;my&quot;,&quot;tuple&quot;,false,0xff9a853c12)=nil</code></pre>
  <p>Including a variable in the directory path tells FQL to perform the
  read on all directory paths matching the schema.</p>
  <pre class="language-fql query"><code>/&lt;&gt;/directory(&quot;my&quot;,&quot;tuple&quot;)</code></pre>
  <pre class="language-fql result"><code>/my/directory(&quot;my&quot;,&quot;tuple&quot;)=0x0fa0
/your/directory(&quot;my&quot;,&quot;tuple&quot;)=nil</code></pre>
  <p>Key-values may be cleared by using the special <code>clear</code>
  token as the value.</p>
  <pre class="language-fql query"><code>/my/directory(&quot;my&quot;,&quot;tuple&quot;)=clear</code></pre>
  <p>The directory layer may be queried by only including a directory
  path.</p>
  <pre class="language-fql query"><code>/my/&lt;&gt;</code></pre>
  <pre class="language-fql result"><code>/my/directory</code></pre>
  <h2 id="data-elements">Data Elements</h2>
  <p>An FQL query contains instances of data elements. These mirror the
  types of elements found in the <a
  href="https://github.com/apple/foundationdb/blob/main/design/tuple.md">tuple
  layer</a>. This section will describe how data elements behave in the
  FQL language, while <a href="#data-encoding">element encoding</a>
  describes how FQL encodes the elements before writing them to the
  DB.</p>
  <pre class="language-ebnf grammar"><code>data = &#39;nil&#39; | bool | int | num | string | uuid
     | bytes | tuple | vstamp | hole
bool = &#39;true&#39; | &#39;false&#39;
int = [ &#39;-&#39; ] digits
num = int &#39;.&#39; digits | ( int | int &#39;.&#39; digits ) &#39;e&#39; int
string = &#39;&quot;&#39; { char | &#39;\&quot;&#39; } &#39;&quot;&#39;
uuid = hex{8} &#39;-&#39; hex{4} &#39;-&#39; hex{4} &#39;-&#39; hex{4} &#39;-&#39; hex{12}
bytes = &#39;0x&#39; { hex{2} }
vstamp = &#39;#&#39; [ hex{20} ] &#39;:&#39; hex{4}</code></pre>
  <div>
  <table>
  <thead>
  <tr>
  <th style="text-align: left;">Type</th>
  <th style="text-align: left;">Description</th>
  <th style="text-align: left;">Examples</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td style="text-align: left;"><code>nil</code></td>
  <td style="text-align: left;">Empty Type</td>
  <td style="text-align: left;"><code>nil</code></td>
  </tr>
  <tr>
  <td style="text-align: left;"><code>bool</code></td>
  <td style="text-align: left;">Boolean</td>
  <td style="text-align: left;"><code>true</code>
  <code>false</code></td>
  </tr>
  <tr>
  <td style="text-align: left;"><code>int</code></td>
  <td style="text-align: left;">Signed Integer</td>
  <td style="text-align: left;"><code>-14</code> <code>3033</code></td>
  </tr>
  <tr>
  <td style="text-align: left;"><code>num</code></td>
  <td style="text-align: left;">Floating Point</td>
  <td style="text-align: left;"><code>33.4</code>
  <code>-3.2e5</code></td>
  </tr>
  <tr>
  <td style="text-align: left;"><code>str</code></td>
  <td style="text-align: left;">Unicode String</td>
  <td style="text-align: left;"><code>"happyüòÅ"</code>
  <code>"\"quoted\""</code></td>
  </tr>
  <tr>
  <td style="text-align: left;"><code>uuid</code></td>
  <td style="text-align: left;">UUID</td>
  <td
  style="text-align: left;"><code>5a5ebefd-2193-47e2-8def-f464fc698e31</code></td>
  </tr>
  <tr>
  <td style="text-align: left;"><code>bytes</code></td>
  <td style="text-align: left;">Byte String</td>
  <td style="text-align: left;"><code>0xa2bff2438312aac032</code></td>
  </tr>
  <tr>
  <td style="text-align: left;"><code>tup</code></td>
  <td style="text-align: left;">Tuple</td>
  <td style="text-align: left;"><code>("hello",27.4,nil)</code></td>
  </tr>
  <tr>
  <td style="text-align: left;"><code>vstamp</code></td>
  <td style="text-align: left;">Version Stamp</td>
  <td style="text-align: left;"><code>#:0000</code>
  <code>#0102030405060708090a:0000</code></td>
  </tr>
  </tbody>
  </table>
  </div>
  <p>The <code>nil</code> type may only be instantiated as the element
  <code>nil</code>. The <code>int</code> type may be instantiated as any
  arbitrarily large integer. For example, the integer in the query below
  doesn‚Äôt fit in a 64-bit value.</p>
  <pre><code>/bigint(92233720368547758084)=nil</code></pre>
  <p>The <code>num</code> type may be instantiated as any real number
  which can be approximated by an <a
  href="https://en.wikipedia.org/wiki/Extended_precision#x86_extended_precision_format">80-bit
  floating point</a> value, in accordance with IEEE 754. The
  implementation determines the exact range of allowed values.
  Scientific notation may be used. The type may also be instantiated as
  the tokens <code>-inf</code>, <code>inf</code>, <code>-nan</code>, or
  <code>nan</code>.</p>
  <pre class="language-fql query"><code>/float(-inf,nan)=1.234e4732</code></pre>
  <p>The <code>str</code> type may be instantiated as a unicode string
  wrapped in double quotes. It is the only element type allowed in
  directory paths. If a directory string only contains alphanumericals,
  underscores, dashes, and periods then the quotes may be excluded.
  Quoted strings may contain double quotes via backslash escapes.</p>
  <pre class="language-fql query"><code>/quoteless-string_in.dir(&quot;escape \&quot;wow\&quot;&quot;)=nil
/&quot;other ch@r@cters must be &#39;quoted&#39;&quot;(nil)=&quot;&quot;</code></pre>
  <p>The <code>uuid</code> and <code>bytes</code> types may be
  instantiated using upper, lower, or mixed case hexidecimal numbers.
  For <code>uuid</code>, the numbers are grouped in the standard 8, 4,
  4, 4, 12 format. For <code>bytes</code>, any even number of
  hexidecimal digits are prefixed by <code>0x</code>.</p>
  <pre class="language-fql query"><code>/hex(fC2Af671-a248-4AD6-ad57-219cd8a9f734)=0x3b42ADED28b9</code></pre>
  <p>The <code>tup</code> type may contain any of the data elements,
  including sub-tuples.</p>
  <pre class="language-fql query"><code>/sub/tuple(&quot;japan&quot;,(&quot;sub&quot;,nil))=0xff
/tuple/value(22.3,-8)=(&quot;rain&quot;,&quot;fog&quot;)</code></pre>
  <p>The <code>vstamp</code> type represents a FoundationDB <a
  href="https://apple.github.io/foundationdb/api-general.html#versionstamps">versionstamp</a>.
  A versionstamp contains a 10-byte transaction version and a 2-byte
  user version. The transaction version is assigned by the database at
  commit time. A vstamp without the transaction version (only the user
  version after the colon) is incomplete and will be filled in by
  FoundationDB when written.</p>
  <pre class="language-fql query"><code>/events(#:0001)=&quot;first event&quot;
/events(#0102030405060708090a:0002)=&quot;second event&quot;</code></pre>
  <h2 id="tuples">Tuples</h2>
  <p>Tuples are ordered sequences of data elements. They are a
  fundamental building block in FQL, used to construct keys and
  values.</p>
  <pre class="language-ebnf grammar"><code>tuple = &#39;(&#39; [ nl elements [ &#39;,&#39; ] nl ] &#39;)&#39;
elements = element [ &#39;,&#39; nl elements ]
element = data | &#39;...&#39;</code></pre>
  <p>A tuple is specified as a sequence of elements, separated by
  commas, wrapped in parentheses. The elements may be any <a
  href="#data-elements">data element</a>, including nested tuples.</p>
  <pre class="language-fql query"><code>(&quot;one&quot;,2,0x03,(&quot;subtuple&quot;),5825d3f8-de5b-40c6-ac32-47ea8b98f7b4)</code></pre>
  <p>A trailing comma is allowed after the last element.</p>
  <pre class="language-fql query"><code>(
  1,
  2,
  3,
)</code></pre>
  <p>The <code>...</code> token can appear as the last element of a
  tuple. It represents any number of additional elements.</p>
  <pre class="language-fql query"><code>(0xFF,&quot;thing&quot;,...)</code></pre>
  <h2 id="directories">Directories</h2>
  <p>Directories provide a way to organize key-values into hierarchical
  namespaces. The <a
  href="https://apple.github.io/foundationdb/developer-guide.html#directories">directory
  layer</a> manages these namespaces and assigns short prefixes to
  keys.</p>
  <pre class="language-ebnf grammar"><code>directory = &#39;/&#39; element [ directory ]
element = &#39;&lt;&gt;&#39; | name | string
name = { alphanumeric | &#39;.&#39; | &#39;-&#39; | &#39;_&#39; }</code></pre>
  <p>A directory is specified as a sequence of strings, each prefixed by
  a forward slash.</p>
  <pre class="language-fql query"><code>/my/dir/path_way</code></pre>
  <p>Strings do not need quotes if they only contain alphanumericals,
  underscores, dashes, or periods. To use other symbols, the strings
  must be quoted.</p>
  <pre class="language-fql query"><code>/my/&quot;dir@--\o/&quot;/path_way</code></pre>
  <p>The quote character may be backslash escaped.</p>
  <pre class="language-fql query"><code>/my/&quot;\&quot;dir\&quot;&quot;/path_way</code></pre>
  <p>The empty variable <code>&lt;&gt;</code> may be used in a directory
  path as a placeholder for any directory name.</p>
  <pre class="language-fql query"><code>/root/&lt;&gt;/items</code></pre>
  <h2 id="key-values">Key-Values</h2>
  <p>A key-value combines a directory, tuple, and value. The key is
  always the directory plus the tuple. The value follows the
  <code>=</code> sign.</p>
  <pre class="language-ebnf grammar"><code>keyval = key &#39;=&#39; value
key = directory tuple
value = &#39;clear&#39; | data</code></pre>
  <pre class="language-fql query"><code>/my/dir(&quot;this&quot;,0)=0xabcf03</code></pre>
  <p>The value may be any <a href="#data-elements">data element</a> or a
  <a href="#tuples">tuple</a>.</p>
  <pre class="language-fql query"><code>/my/dir(22.3,-8)=(&quot;another&quot;,&quot;tuple&quot;)</code></pre>
  <p>The value can also be the <code>clear</code> token, which is used
  to delete key-values.</p>
  <pre class="language-fql query"><code>/some/where(&quot;home&quot;,&quot;town&quot;,88.3)=clear</code></pre>
  <p>If a query omits the value entirely, an empty variable
  <code>&lt;&gt;</code> is implied, making it a read query.</p>
  <pre class="language-fql"><code>/my/dir(99.8,0xff)
/my/dir(99.8,0xff)=&lt;&gt;</code></pre>
  <p>The two queries above are equivalent.</p>
  <h2 id="holes-schemas">Holes &amp; Schemas</h2>
  <p>Holes are a group of syntax constructs used to define a key-value
  schema by acting as placeholders for one or more data elements. There
  are three kinds of holes: variables, references, and the
  <code>...</code> token.</p>
  <pre class="language-ebnf grammar"><code>hole = variable | reference | &#39;...&#39;
variable = &#39;&lt;&#39; [ name &#39;:&#39; ] [ type { &#39;|&#39; type } ] &#39;&gt;&#39;
reference = &#39;:&#39; name
type = &#39;any&#39; | &#39;tuple&#39; | &#39;bool&#39; | &#39;int&#39; | &#39;num&#39;
     | &#39;str&#39; | &#39;uuid&#39; | &#39;bytes&#39; | &#39;vstamp&#39;</code></pre>
  <p>Variables are used to represent a single <a
  href="#data-elements">data element</a>. Variables are specified as a
  list of element types, separated by <code>|</code>, wrapped in angled
  braces.</p>
  <pre class="language-fql"><code>&lt;int|str|uuid|bytes&gt;</code></pre>
  <p>The variable‚Äôs type list describes which kinds of data elements are
  allowed at the variable‚Äôs position. A variable may be empty, including
  no element types, meaning it represents all element types.</p>
  <pre class="language-fql query"><code>/data(&lt;int&gt;,&lt;str|int&gt;,&lt;&gt;)=&lt;&gt;</code></pre>
  <pre class="language-fql result"><code>/data(0,&quot;jon&quot;,0xffab0c)=nil
/data(20,3,22.3)=0xff
/data(21,&quot;&quot;,nil)=nil</code></pre>
  <p>References allow two queries to be connected via a variable‚Äôs name,
  allowing for <a href="#indirection">index indirection</a>. Before the
  type list, a variable may include a name. The reference is specified
  as a variable‚Äôs name prefixed with a <code>:</code>.</p>
  <pre class="language-fql query"><code>/index(&quot;cars&quot;,&lt;varName:int&gt;)
/data(:varName,...)</code></pre>
  <pre class="language-fql result"><code>/data(33,&quot;mazda&quot;)=nil
/data(320,&quot;ford&quot;)=nil
/data(411,&quot;chevy&quot;)=nil</code></pre>
  <p>Named variables must include at least one type. To allow named
  variables to match any element type, use the <code>any</code>
  type.</p>
  <pre class="language-fql"><code>/stuff(&lt;thing:any&gt;)</code></pre>
  <pre class="language-fql result"><code>/stuff(&quot;cat&quot;)
/stuff(42)
/stuff(0x5fae)</code></pre>
  <p>The <code>...</code> token represents any number of data elements
  of any type. It is only allowed as the last element of a tuple.</p>
  <pre class="language-fql"><code>/tuples(0x00,...)</code></pre>
  <pre class="language-fql result"><code>/tuples(0x00)=nil
/tuples(0x00,&quot;something&quot;)=nil
/tuples(0x00,42,43,44)=0xabcf</code></pre>
  <h2 id="space-comments">Space &amp; Comments</h2>
  <p>Whitespace and newlines are allowed within a tuple, between its
  elements.</p>
  <pre class="language-fql query"><code>/account/private(
  &lt;int&gt;,
  &lt;int&gt;,
  &lt;str&gt;,
)=&lt;int&gt;</code></pre>
  <p>Comments start with a <code>%</code> and continue until the end of
  the line. They can be used to describe a tuple‚Äôs elements.</p>
  <pre class="language-fql"><code>% private account balances
/account/private(
  &lt;int&gt;,  % group ID
  &lt;int&gt;,  % account ID
  &lt;str&gt;,  % account name
)=&lt;int&gt;   % balance in USD</code></pre>
  <h2 id="options">Options</h2>
  <p>Options modify the semantics of <a href="#data-elements">data
  elements</a>, <a href="#holes-schemas">variables</a>, and <a
  href="#query-types">queries</a>. They can instruct FQL to use
  alternative encodings, limit a query‚Äôs result count, or change other
  behaviors.</p>
  <pre class="language-ebnf grammar"><code>options = &#39;[&#39; option { &#39;,&#39; option } &#39;]&#39; nl
option = name [ &#39;:&#39; argument ]
argument = name | int</code></pre>
  <p>Options are specified as a comma separated list wrapped in
  brackets. For instance, to specify that an <code>int</code> should be
  encoded as a little-endian unsigned 8-bit integer, the following
  options would be included after the element.</p>
  <pre class="language-fql"><code>3548[u8,le]</code></pre>
  <p>Similarly, if a variable should only match against a big-endian
  32-bit float then the following options would be included after the
  <code>num</code> type.</p>
  <pre class="language-fql"><code>&lt;num[f32,be]&gt;</code></pre>
  <p>By default, <a href="#holes-schemas">variables</a> will decode any
  encoding for their types. Options may be applied to a variable‚Äôs types
  to limit which encodings will match the schema.</p>
  <pre class="language-fql query"><code>/numbers(&lt;int[i16,be]&gt;)=&lt;num[f32]&gt;</code></pre>
  <p>If an element‚Äôs value cannot be represented by the specified
  encoding then the query is invalid.</p>
  <pre class="language-fql query"><code>/numbers(362342[i16])=32.55[f32]</code></pre>
  <h3 id="element-options">Element Options</h3>
  <p>The tables below show which options are supported for the
  <code>int</code> and <code>num</code> types when used as values. These
  options control how the data is serialized to bytes.</p>
  <div>
  <table>
  <thead>
  <tr>
  <th style="text-align: left;">Int Option</th>
  <th style="text-align: left;">Description</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td style="text-align: left;"><code>be</code></td>
  <td style="text-align: left;">Big endian</td>
  </tr>
  <tr>
  <td style="text-align: left;"><code>le</code></td>
  <td style="text-align: left;">Little endian</td>
  </tr>
  <tr>
  <td style="text-align: left;"><code>u8</code></td>
  <td style="text-align: left;">Unsigned 8-bit</td>
  </tr>
  <tr>
  <td style="text-align: left;"><code>u16</code></td>
  <td style="text-align: left;">Unsigned 16-bit</td>
  </tr>
  <tr>
  <td style="text-align: left;"><code>u32</code></td>
  <td style="text-align: left;">Unsigned 32-bit</td>
  </tr>
  <tr>
  <td style="text-align: left;"><code>u64</code></td>
  <td style="text-align: left;">Unsigned 64-bit</td>
  </tr>
  <tr>
  <td style="text-align: left;"><code>i8</code></td>
  <td style="text-align: left;">Signed 8-bit</td>
  </tr>
  <tr>
  <td style="text-align: left;"><code>i16</code></td>
  <td style="text-align: left;">Signed 16-bit</td>
  </tr>
  <tr>
  <td style="text-align: left;"><code>i32</code></td>
  <td style="text-align: left;">Signed 32-bit</td>
  </tr>
  <tr>
  <td style="text-align: left;"><code>i64</code></td>
  <td style="text-align: left;">Signed 64-bit</td>
  </tr>
  </tbody>
  </table>
  </div>
  <div>
  <table>
  <thead>
  <tr>
  <th style="text-align: left;">Num Option</th>
  <th style="text-align: left;">Description</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td style="text-align: left;"><code>be</code></td>
  <td style="text-align: left;">Big endian</td>
  </tr>
  <tr>
  <td style="text-align: left;"><code>le</code></td>
  <td style="text-align: left;">Little endian</td>
  </tr>
  <tr>
  <td style="text-align: left;"><code>f32</code></td>
  <td style="text-align: left;">32-bit</td>
  </tr>
  <tr>
  <td style="text-align: left;"><code>f64</code></td>
  <td style="text-align: left;">64-bit</td>
  </tr>
  <tr>
  <td style="text-align: left;"><code>f80</code></td>
  <td style="text-align: left;">80-bit</td>
  </tr>
  </tbody>
  </table>
  </div>
  <h3 id="query-options">Query Options</h3>
  <p>Query options are specified on the line before the query. For
  instance, to specify that a range-read query should read in reverse
  and only read 5 items, the following options would be included before
  the query.</p>
  <pre class="language-fql query"><code>[reverse,limit:5]
/my/integers(&lt;int&gt;)=nil</code></pre>
  <p>Notice that the <code>limit</code> option includes an argument
  after the colon. Some options include a single argument to further
  specify the option‚Äôs behavior.</p>
  <div>
  <table>
  <thead>
  <tr>
  <th style="text-align: left;">Query Option</th>
  <th style="text-align: left;">Argument</th>
  <th style="text-align: left;">Description</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td style="text-align: left;"><code>reverse</code></td>
  <td style="text-align: left;">none</td>
  <td style="text-align: left;">Read range in reverse order</td>
  </tr>
  <tr>
  <td style="text-align: left;"><code>limit</code></td>
  <td style="text-align: left;">int</td>
  <td style="text-align: left;">Maximum number of results</td>
  </tr>
  <tr>
  <td style="text-align: left;"><code>strict</code></td>
  <td style="text-align: left;">none</td>
  <td style="text-align: left;">Error on non-conformant key-values</td>
  </tr>
  </tbody>
  </table>
  </div>
  <h1 id="semantics">Semantics</h1>
  <h2 id="data-encoding">Data Encoding</h2>
  <p>FoundationDB stores the keys and values as simple byte strings
  leaving the client responsible for encoding the data. FQL determines
  how to encode <a href="#data-elements">data elements</a> based on
  their data type, position within the query, and associated <a
  href="#options">options</a>.</p>
  <p>Keys are <em>always</em> encoded using the <a
  href="https://apple.github.io/foundationdb/developer-guide.html#directories">directory</a>
  and <a
  href="https://apple.github.io/foundationdb/data-modeling.html#data-modeling-tuples">tuple</a>
  layers. Write queries create directories if they do not exist.</p>
  <pre class="language-fql query"><code>/directory/&quot;p@th&quot;(nil,57223,0xa8ff03)=nil</code></pre>
  <pre class="lang-python equiv-py"><code>@fdb.transactional
def write_kv(tr):
    # Open directory; create if doesn&#39;t exist
    dir = fdb.directory.create_or_open(tr, (&#39;directory&#39;, &#39;p@th&#39;))

    # Pack the tuple and prepend the directory prefix
    key = dir.pack((None, 57223, b&#39;\xa8\xff\x03&#39;))

    # Write the KV
    tr[key] = b&#39;&#39;</code></pre>
  <p>If a query reads from a directory which doesn‚Äôt exist, nothing is
  returned. The tuple layer encodes metadata about element types,
  allowing FQL to decode keys without a schema.</p>
  <pre class="language-fql query"><code>/directory/&lt;&gt;(...)</code></pre>
  <pre class="lang-python equiv-py"><code>@fdb.transactional
def read_kvs(tr):
    # Open directory; exit if it doesn&#39;t exist
    dir = fdb.directory.open(tr, (&#39;directory&#39;,))
    if dir is None:
        return []

    # List the sub-directories
    sub_dirs = dir.list(tr)

    # For each sub-directory, grab all the KVs
    results = []
    for sub_name in sub_dirs:
        sub_dir = dir.open(tr, (sub_name,))
        for key, val in tr[sub_dir.range()]:
            # Remove the directory prefix and unpack the tuple
            tup = sub_dir.unpack(key)
            # Value unpacking will be discussed later...
            results.append((sub_dir.get_path(), tup, val))

    return results</code></pre>
  <p>Values have more flexible encoding options. There is a default
  encoding where data elements are encoded as the lone member of a
  tuple. For instance, the value <code>42</code> is encoded as the tuple
  <code>(42)</code>.</p>
  <p>The exceptions to this default encoding are when values are tuples
  (which are not wrapped in another tuple) and byte strings (which are
  used as-is for the value).</p>
  <pre class="language-fql query"><code>/people/age(&quot;jon&quot;,&quot;smith&quot;)=42</code></pre>
  <pre class="lang-python equiv-py"><code>@fdb.transactional
def write_age(tr):
    dir = fdb.directory.create_or_open(tr, (&#39;people&#39;, &#39;age&#39;))
    key = dir.pack((&#39;jon&#39;, &#39;smith&#39;))

    # Pack the value as a tuple
    val = fdb.tuple.pack((42,))

    # Write the KV
    tr[key] = val</code></pre>
  <p>This default encoding allows values to be decoded without knowing
  their type.</p>
  <pre class="language-fql query"><code>/people/age(&quot;jon&quot;,&quot;smith&quot;)=&lt;&gt;</code></pre>
  <pre class="lang-python equiv-py"><code>@fdb.transactional
def read_age(tr):
    dir = fdb.directory.open(tr, (&#39;people&#39;, &#39;age&#39;))
    key = dir.pack((&#39;jon&#39;, &#39;smith&#39;))

    # Read the value
    val_bytes = tr[key]

    # Assume the value is a tuple
    try:
        val_tup = fdb.tuple.unpack(val_bytes)
        if len(val_tup) == 1:
            return val_tup[0]
        return val_tup
    except:
        # If decoding as a tuple fails, return raw bytes
        return val_bytes</code></pre>
  <p>Using options, values can be encoded in other ways. For instance,
  the option <code>u16</code> tells FQL to encode an integer as an
  unsigned 16-bit integer. The byte order can be specified using the
  options <code>le</code> and <code>be</code> for little and big endian
  respectively.</p>
  <pre class="language-fql query"><code>/numbers/big(&quot;37&quot;)=37[i16,be]</code></pre>
  <pre class="lang-python equiv-py"><code>import struct

@fdb.transactional
def write_int(tr):
    dir = fdb.directory.create_or_open(tr, (&#39;numbers&#39;, &#39;big&#39;))
    key = dir.pack((&#39;37&#39;,))

    # Pack the value into signed 16-bit big endian
    val = struct.pack(&#39;&gt;h&#39;, 37)

    # Write the KV
    tr[key] = val</code></pre>
  <p>If the value was encoded with non-default values, then the encoding
  must be specified in the variable when read.</p>
  <pre class="language-fql query"><code>/numbers/big(&quot;37&quot;)=&lt;int[i16,be]&gt;</code></pre>
  <pre class="lang-python equiv-py"><code>import struct

@fdb.transactional
def read_int(tr):
    dir = fdb.directory.open(tr, (&#39;numbers&#39;, &#39;big&#39;))
    key = dir.pack((&#39;37&#39;,))

    # Read the value
    val_bytes = tr[key]

    # Unpack value as a 16-bit signed int, big endian
    val = struct.unpack(&#39;&gt;h&#39;, val_bytes)[0]

    return val</code></pre>
  <h2 id="query-types">Query Types</h2>
  <p>FQL queries may mutate a single key-value, read one or more
  key-values, or list directories. Throughout this section, snippets of
  Python code are included which approximate how the queries interact
  with the FoundationDB API.</p>
  <h3 id="mutations">Mutations</h3>
  <p>Queries lacking <a href="#holes-schemas">holes</a> perform
  mutations on the database by either writing or clearing a
  key-value.</p>
  <blockquote>
  <p>‚ùó Queries lacking a value altogether imply an empty <a
  href="#holes-schemas">variable</a> as the value and should not be
  confused with mutation queries.</p>
  </blockquote>
  <p>Mutation queries with a <a href="#data-elements">data element</a>
  as their value perform a write operation.</p>
  <pre class="language-fql query"><code>/my/dir(&quot;hello&quot;,&quot;world&quot;)=42</code></pre>
  <pre class="lang-python equiv-py"><code>@fdb.transactional
def set_kv(tr):
    dir = fdb.directory.create_or_open(tr, (&#39;my&#39;, &#39;dir&#39;))

    # Pack value as tuple (default encoding)
    val = fdb.tuple.pack((42,))

    tr[dir.pack((&#39;hello&#39;, &#39;world&#39;))] = val</code></pre>
  <p>Mutation queries with the <code>clear</code> token as their value
  perform a clear operation.</p>
  <pre class="language-fql query"><code>/my/dir(&quot;hello&quot;,&quot;world&quot;)=clear</code></pre>
  <pre class="lang-python equiv-py"><code>@fdb.transactional
def clear_kv(tr):
    dir = fdb.directory.open(tr, (&#39;my&#39;, &#39;dir&#39;))
    if dir is None:
        return

    del tr[dir.pack((&#39;hello&#39;, &#39;world&#39;))]</code></pre>
  <h3 id="reads">Reads</h3>
  <p>Queries containing <a href="#holes-schemas">holes</a> read one or
  more key-values. If the holes only appears in the value, then a single
  key-value is returned, if one matching the schema exists.</p>
  <blockquote>
  <p>‚ùó Queries lacking a value altogether imply an empty <a
  href="#holes-schemas">variable</a> as the value which makes them read
  queries.</p>
  </blockquote>
  <pre class="language-fql query"><code>/my/dir(99.8,7dfb10d1-2493-4fb5-928e-889fdc6a7136)=&lt;int|str&gt;</code></pre>
  <pre class="lang-python equiv-py"><code>import struct
import uuid

@fdb.transactional
def read_single(tr):
    dir = fdb.directory.open(tr, (&#39;my&#39;, &#39;dir&#39;))
    if dir is None:
        return None

    # Read the value&#39;s raw bytes
    key = dir.pack((99.8, uuid.UUID(&#39;7dfb10d1-2493-4fb5-928e-889fdc6a7136&#39;)))
    val = tr[key]

    # Try to decode the value as an int
    if len(val) == 8:
        return struct.unpack(&#39;&lt;q&#39;, val)[0]

    # If the value isn&#39;t an int, assume it&#39;s a string
    return val.decode(&#39;utf-8&#39;)</code></pre>
  <p>FQL attempts to decode the value as each of the types listed in the
  variable, stopping at first success. If the value cannot be decoded,
  the key-value does not match the schema.</p>
  <p>If the value is specified as an empty variable, then the raw bytes
  are returned.</p>
  <pre class="language-fql query"><code>/some/data(10139)=&lt;&gt;</code></pre>
  <pre class="lang-python equiv-py"><code>@fdb.transactional
def read_raw(tr):
    dir = fdb.directory.open(tr, (&#39;some&#39;, &#39;data&#39;))
    if dir is None:
        return None

    # No value decoding...
    return tr[dir.pack((10139,))]</code></pre>
  <p>Queries with <a href="#holes-schemas">variables</a> in their key
  (and optionally in their value) result in a range of key-values being
  read.</p>
  <pre class="language-fql query"><code>/people(&quot;coders&quot;,...)</code></pre>
  <pre class="lang-python equiv-py"><code>@fdb.transactional
def read_range(tr):
    dir = fdb.directory.open(tr, (&#39;people&#39;,))
    if dir is None:
        return []

    # Create a range for the prefix
    prefix = dir.pack((&#39;coders&#39;,))
    range_result = tr[fdb.Range(prefix, fdb.strinc(prefix))]

    results = []
    for key, val in range_result:
        tup = dir.unpack(key)
        results.append((tup, val))

    return results</code></pre>
  <h3 id="directories-1">Directories</h3>
  <p>The directory layer may be queried in isolation by using a lone
  directory as a query. These queries can only perform reads. If the
  directory path contains no variables, the query will read that single
  directory.</p>
  <pre class="language-fql query"><code>/root/&lt;&gt;/items</code></pre>
  <pre class="lang-python equiv-py"><code>@fdb.transactional
def list_dirs(tr):
    root = fdb.directory.open(tr, (&#39;root&#39;,))
    if root is None:
        return []

    # List the sub-directories
    one_deep = root.list(tr)

    results = []
    for dir1 in one_deep:
        # Check if &#39;items&#39; exists under each sub-directory
        items = root.open(tr, (dir1, &#39;items&#39;))
        if items is not None:
            results.append((&#39;root&#39;, dir1, &#39;items&#39;))

    return results</code></pre>
  <h3 id="filtering">Filtering</h3>
  <p>Read queries define a schema to which key-values may or may-not
  conform. In the Python snippets above, non-conformant key-values were
  being filtered out of the results.</p>
  <p>Alternatively, FQL can throw an error when encountering
  non-conformant key-values. This may help enforce the assumption that
  all key-values within a directory conform to a certain schema. See the
  <code>strict</code> <a href="#query-options">query option</a>.</p>
  <p>Because filtering is performed on the client side, range reads may
  stream a lot of data to the client while the client filters most of it
  away. For example, consider the following query:</p>
  <pre class="language-fql query"><code>/people(3392,&lt;str|int&gt;,&lt;&gt;)=(&lt;int&gt;,...)</code></pre>
  <p>In the key, the location of the first variable or <code>...</code>
  token determines the range read prefix used by FQL. For this
  particular query, the prefix would be as follows:</p>
  <pre class="language-fql query"><code>/people(3392)</code></pre>
  <p>FoundationDB will stream all key-values with this prefix to the
  client. As they are received, the client will filter out key-values
  which don‚Äôt match the query‚Äôs schema. Below you can see a Python
  implementation of how this filtering would work.</p>
  <pre class="lang-python"><code>@fdb.transactional
def filter_range(tr):
    dir = fdb.directory.open(tr, (&#39;people&#39;,))
    if dir is None:
        return []

    prefix = dir.pack((3392,))
    range_result = tr[fdb.Range(prefix, fdb.strinc(prefix))]

    results = []
    for key, val in range_result:
        tup = dir.unpack(key)

        # Our query specifies a key-tuple with 3 elements
        if len(tup) != 3:
            continue

        # The 2nd element must be either a string or an int
        if not isinstance(tup[1], (str, int)):
            continue

        # The query tells us to assume the value is a packed tuple
        try:
            val_tup = fdb.tuple.unpack(val)
        except:
            continue

        # The value-tuple must have one or more elements
        if len(val_tup) == 0:
            continue

        # The first element of the value-tuple must be an int
        if not isinstance(val_tup[0], int):
            continue

        results.append((tup, val_tup))

    return results</code></pre>
  <h2 id="advanced-queries">Advanced Queries</h2>
  <p>Besides basic CRUD operations, FQL is capable of performing
  indirection queries.</p>
  <h3 id="indirection">Indirection</h3>
  <p>Indirection queries are similar to SQL joins. They associate
  different groups of key-values via some shared data element.</p>
  <p>In FoundationDB, indexes are implemented using indirection. Suppose
  we have a large list of people, one key-value for each person.</p>
  <pre class="language-fql query"><code>/people(
  &lt;int&gt;, % ID
  &lt;str&gt;, % First Name
  &lt;str&gt;, % Last Name
  &lt;int&gt;, % Age
)=nil</code></pre>
  <p>If we wanted to read all records containing the last name
  ‚ÄúJohnson‚Äù, we‚Äôd have to perform a linear search across the entire
  ‚Äúpeople‚Äù directory. To make this kind of search more efficient, we can
  store an index for last names in a separate directory.</p>
  <pre class="language-fql query"><code>/index/last_name(
  &lt;str&gt;, % Last Name
  &lt;int&gt;, % ID
)=nil</code></pre>
  <p>If we query the index, we can get the IDs of the records containing
  the last name ‚ÄúJohnson‚Äù.</p>
  <pre class="language-fql query"><code>/index/last_name(&quot;Johnson&quot;,&lt;int&gt;)</code></pre>
  <pre class="language-fql result"><code>/index/last_name(&quot;Johnson&quot;,23)=nil
/index/last_name(&quot;Johnson&quot;,348)=nil
/index/last_name(&quot;Johnson&quot;,2003)=nil</code></pre>
  <p>FQL can forward the observed values of named variables from one
  query to the next. We can use this to obtain our desired subset from
  the ‚Äúpeople‚Äù directory.</p>
  <pre class="language-fql query"><code>/index/last_name(&quot;Johnson&quot;,&lt;id:int&gt;)
/people(:id,...)</code></pre>
  <pre class="language-fql result"><code>/people(23,&quot;Lenny&quot;,&quot;Johnson&quot;,22,&quot;Mechanic&quot;)=nil
/people(348,&quot;Roger&quot;,&quot;Johnson&quot;,54,&quot;Engineer&quot;)=nil
/people(2003,&quot;Larry&quot;,&quot;Johnson&quot;,8,&quot;N/A&quot;)=nil</code></pre>
  <h1 id="grammar">Grammar</h1>
  <p>The complete FQL grammar is specified below using extended
  Backus-Naur form as defined in ISO/IEC 14977, with two modifications:
  concatenation is implicit and rules terminate at newline.</p>
  <pre class="language-ebnf grammar"><code>(* Top-level query structure *)
query = options keyval | options key | options directory

keyval = key &#39;=&#39; value
key = directory tuple
value = &#39;clear&#39; | data

(* Directories *)
directory = &#39;/&#39; ( &#39;&lt;&gt;&#39; | name | string ) [ directory ]

(* Tuples *)
tuple = &#39;(&#39; [ nl elements [ &#39;,&#39; ] nl ] &#39;)&#39;
elements = element [ &#39;,&#39; nl elements ]
element = data | &#39;...&#39;

(* Data elements *)
data = &#39;nil&#39; | bool | int | num | string | uuid
     | bytes | tuple | vstamp | hole

bool = &#39;true&#39; | &#39;false&#39;
int = [ &#39;-&#39; ] digits
num = int &#39;.&#39; digits | ( int | int &#39;.&#39; digits ) &#39;e&#39; int
string = &#39;&quot;&#39; { char | &#39;\&quot;&#39; } &#39;&quot;&#39;
uuid = hex{8} &#39;-&#39; hex{4} &#39;-&#39; hex{4} &#39;-&#39; hex{4} &#39;-&#39; hex{12}
bytes = &#39;0x&#39; { hex hex }
vstamp = &#39;#&#39; [ hex{20} ] &#39;:&#39; hex{4}

(* Holes *)
hole = variable | reference | &#39;...&#39;
variable = &#39;&lt;&#39; [ name &#39;:&#39; ] [ type { &#39;|&#39; type } ] &#39;&gt;&#39;
reference = &#39;:&#39; name
type = &#39;any&#39; | &#39;tuple&#39; | &#39;bool&#39; | &#39;int&#39; | &#39;num&#39;
     | &#39;str&#39; | &#39;uuid&#39; | &#39;bytes&#39; | &#39;vstamp&#39;

(* Options *)
options = [ &#39;[&#39; option { &#39;,&#39; option } &#39;]&#39; nl ]
option = name [ &#39;:&#39; argument ]
argument = name | int

(* Primitives *)
digits = digit { digit }
digit = &#39;0&#39; | &#39;1&#39; | &#39;2&#39; | &#39;3&#39; | &#39;4&#39; | &#39;5&#39; | &#39;6&#39; | &#39;7&#39; | &#39;8&#39; | &#39;9&#39;
hex = digit | &#39;a&#39; | &#39;b&#39; | &#39;c&#39; | &#39;d&#39; | &#39;e&#39; | &#39;f&#39;
    | &#39;A&#39; | &#39;B&#39; | &#39;C&#39; | &#39;D&#39; | &#39;E&#39; | &#39;F&#39;
name = ( letter | &#39;_&#39; ) { letter | digit | &#39;_&#39; | &#39;-&#39; | &#39;.&#39; }
letter = &#39;a&#39; | ... | &#39;z&#39; | &#39;A&#39; | ... | &#39;Z&#39;
char = ? Any printable ASCII character except &#39;&quot;&#39; ?

(* Whitespace *)
ws = { &#39; &#39; | &#39;\t&#39; }
nl = { &#39; &#39; | &#39;\t&#39; | &#39;\n&#39; | &#39;\r&#39; }</code></pre>
  <!-- vim: set tw=60 :-->
  <script>
    hljs.highlightAll();
    document.querySelectorAll(":not(pre) > code").forEach((e) => {
      let bash = false;
      for (let p = e.parentElement; p; p = p.parentElement) {
        if (p.classList.contains("language-bash")) {
          bash = true;
          break;
        }
      }

      if (bash) e.classList.add("language-bash");
      else e.classList.add("language-fql");
      hljs.highlightElement(e);
    });
  </script>
</body>
</html>
